# load required libraries
library(tidyverse)     # tidyverse will pull in ggplot2, readr, other useful libraries
library(magrittr)      # provides the %>% operator
library(tidyr)
library(pheatmap)
library(WGCNA)
library(RSQLite)
library(BiocManager)
library(DESeq2)
library(genefilter)
library(tibble)
library(readxl)
library(writexl)
library(limma)
library(edgeR)

# set working 
setwd("/Users/natecollison/Desktop/DV_RNAseq_10.2023")

getwd()

### use edgeR cpm function to filter out genes that have less than 0.5 counts per million gene counts (cpm)

# read in the gene count matrix generated by STAR aligner
STAR_counts <- read.delim("stargenecount.txt")

count_data_merged <- STAR_counts

# add gene ID as row name
rownames(count_data_merged)<-count_data_merged$gene_id
rownames(count_data_merged)

# remove first row to get only count data
count_data_merged<- count_data_merged[-c(1)]

# check library sizes (gene counts)
library.sizes <- colSums(count_data_merged)
library.sizes  
range(library.sizes)
# [1] 15,185,653 - 26,233,968 STAR counts

# create data frame for the edgeR DGElist object
targetdata<-data.frame(FileName=colnames(count_data_merged),Group=c(rep("G1103",4), rep("G101_14",4), rep("G99R",4), rep("G0_cab33",4), rep("G1_cab33",4),rep("GS04",4)))
targetdata$Gp2<-factor(targetdata$Group)
targetdata$Gp2<-as.numeric(targetdata$Gp2)
targetdata

# create DGElist object
x<-DGEList(counts=as.matrix(count_data_merged),lib.size=library.sizes,group=targetdata$Group)

class(x)
dim(x) 
colnames(x)

samplenames <- substring(colnames(x), 1, nchar(colnames(x)))
samplenames
colnames(x) <- samplenames
colnames(x)
rownames(x)

group <- as.factor(c( "G1103", "G1103", "G1103", "G1103","G101_14", "G101_14", "G101_14", "G101_14",  "G99R", "G99R", "G99R", "G99R","G0_cab33", "G0_cab33", "G0_cab33", "G0_cab33", "G1_cab33", "G1_cab33", "G1_cab33", "G1_cab33", "GS04", "GS04","GS04", "GS04"))

x$samples$group <- group
x$samples


# filter out gene with insufficient count data, less than 0.5 cpm
?cpm
countsPerMillion <- cpm(x)
summary(countsPerMillion)
countCheck<- countsPerMillion > 0.5

head(countCheck)
tail(countCheck)

# keep only genes that have >0.5 cpm in 4 or more samples
keep<- which(rowSums(countCheck) >= 4/24)
x <- x[keep,]


# Convert row names to a column
filtered_count_df <- tibble::rownames_to_column(filtered_count_df, var = "RowNames")

# Write the DataFrame to an Excel file
writexl::write_xlsx(filtered_count_df, "filtered_by_0.5cpm_all_counts.xlsx")




### Perform WGCNA analysis

# read in the 0.5-cpm-filtered count data and format for WGCNA
STAR_counts <- read_xlsx("filtered_by_0.2cpm_all_counts.xlsx")
colnames(STAR_counts)[1] ="ID"
STAR_counts<- STAR_counts[c(1)]

# merge the filtered count data with the initial raw count data (need to transform data back to raw integers, not scientific notation)
STAR_counts_raw <- read.delim("stargenecount.txt")
colnames(STAR_counts_raw)[1] ="ID"
count_data_merged <- merge(STAR_counts,STAR_counts_raw, by = 'ID', all = FALSE)

# add gene ID as the row name
rownames(count_data_merged)<-count_data_merged$ID
rownames(count_data_merged)

#reformat data matrix for WGCNA
data<- count_data_merged
dim(data)

col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel)
  ) %>%  
  mutate(
    group = gsub("_.*","", name) %>% gsub("[.].*","", .)   # Get the shorter treatment names
  )


#Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers; non-normalized data
(
  p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups", y = "RNA Seq Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
)

de_input = as.matrix(data[,-1])
row.names(de_input) = data$ID
de_input[1:5,1:10]


meta_df <- data.frame( Sample = names(data[-1])) %>%
  mutate(
    Type = gsub("_.*","", Sample) %>% gsub("[.].*","", .)
  )


# Create a `DESeqDataSet` object
dds <- DESeqDataSetFromMatrix(
  countData = de_input,
  colData = meta_df,
  design = ~1
)

# Normalize and transform the data in the `DESeqDataSet` object using the `vst()`
dds_norm <- vst(dds)

# Retrieve the normalized data from the `DESeqDataSet`
expr_normalized <- assay(dds_norm)

#check structure of data object
expr_normalized[1:5,1:10]

dim(expr_normalized)
#[1] 13,918    24

# plot expression data
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text( angle = 90)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Gene Expression vs Treatment",
    x = "sample",
    y = "vst normalized expression"
  )


# transpose data for WCGNA
input_mat = t(expr_normalized)

input_mat[1:5,1:10]

# save gene expression data file 
save(input_mat, file = "normalized_gene_exprs_07232024.RData")

allowWGCNAThreads(8)    # allow multi-threading (optional)      

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  networkType = "signed"
)

sft$powerEstimate

# making plots
par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.9, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")


## perform hierarchical clustering using softPower 16, approximate scale-free topology for signed network
softPower = 16;
adjacency = adjacency(input_mat, power = softPower);

# Turn adjacency into topological overlap
TOM = TOMsimilarity(adjacency,  TOMType = "signed");
dissTOM = 1-TOM

# Call the hierarchical clustering function
geneTree = hclust(as.dist(dissTOM), method = "average");

# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04);


minModuleSize = 20;
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize);
table(dynamicMods)

# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

mergedColors = labels2colors(dynamicMods)

# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")

# Calculate eigengenes
MEList = moduleEigengenes(input_mat, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");

# Set the size of the graphics window
sizeGrWindow(7, 6)

# Plot the hierarchical clustering of module eigengenes
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "", cex = 0.6)  # Adjust cex to change the font size

# save R data 
save(MEs, dynamicMods, mergedColors, dynamicColors, geneTree, file = "signed_16thpwr_07162024.RData")




### Make a heatmap of module eigengenes using pheatmap
MEs0 <- moduleEigengenes(input_mat, dynamicColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order <- names(MEs0) %>% gsub("ME", "", .)

# Add treatment names
MEs0$treatment <- row.names(MEs0)

# Transform the data to a long format
mME <- MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

# Pivot the data back to a wide format for pheatmap
heatmap_data <- mME %>%
  pivot_wider(names_from = treatment, values_from = value) %>%
  column_to_rownames("name") %>%
  as.matrix()

# Generate the heatmap
pheatmap(
  heatmap_data,
  border_color = NA,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  color = colorRampPalette(c("blue", "white", "red"))(50),
  fontsize_row = 5,  # Adjust the font size for row labels
  fontsize_col = 10, # Adjust the font size for column labels
  main = "Module Eigengene vs Sample",
  annotation_colors = list(Module = c(darkolivegreen4 = "darkolivegreen4"))
)

pheatmap(
  heatmap_data,
  border_color = NA,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  color = colorRampPalette(c("blue", "white", "red3"))(50),
  fontsize_row = 5,  # Adjust the font size for row labels
  fontsize_col = 10, # Adjust the font size for column labels
  main = "Module Eigengene vs Sample",
  annotation_colors = list(Module = c(darkolivegreen4 = "darkolivegreen4"))
)


# save eigengene and module assignment data to excel files 

MEs_with_rownames <- data.frame(RowNames = rownames(MEs), MEs)
writexl::write_xlsx(MEs_with_rownames, "MEs_signed_16thpwr_unmerged_07162024_2.xlsx")


# write gene module assignment file
geneIDs <- colnames(input_mat)

# Use the mergedColors vector for module assignments
moduleAssignments <- mergedColors

# Create a data frame
gene_module_df <- data.frame(GeneID = geneIDs, ModuleAssignment = moduleAssignments)
writexl::write_xlsx(gene_module_df, "gene_mod_assign_signed_16thpwr_unmerged_07162024.xlsx")



### Make a heat map of gene expression for specific modules

library(dplyr)
library(tidyr)
library(ggplot2)
library(pheatmap)

# First, write dataframe with gene name and modules assignment
geneIDs <- colnames(input_mat)
moduleAssignments <- mergedColors
gene_module_df <- data.frame(GeneID = geneIDs, ModuleAssignment = moduleAssignments)

# Specify modules of interest
modules_of_interest = c("darkolivegreen4")

# Pull out list of genes in that module
submod = gene_module_df %>%
  subset(ModuleAssignment %in% modules_of_interest)

row.names(gene_module_df) = gene_module_df$GeneID

# Get normalized expression for those genes
expr_normalized = t(input_mat) # First, transpose gene expression dataframe

subexpr = expr_normalized[submod$GeneID, ]

# Create a heatmap using pheatmap
pheatmap(
  subexpr,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  #scale = "row",
  color = colorRampPalette(c("blue", "white", "red"))(50),
  annotation_colors = list(Module = c(darkolivegreen4 = "darkolivegreen4")),
  fontsize_row = 6,  # Adjust the font size for row labels
  fontsize_col = 10  # Adjust the font size for column labels
)
 









#########

### Using a linear regression to correlate fitness with eigengenes

setwd("/Users/natecollison/Desktop/DV_RNAseq_10.2023")
getwd()

library(readxl)
library(dplyr)
library(ggplot2)

file_path <- "MEs_signed_16thpwr_unmerged_07162024_2.xlsx"
data_matrix <- read_excel(file_path)
head(data_matrix)

# using R to calculate eigengene averages for each genotype
head(data_matrix)
sub("_[0-9]+$", "", data_matrix$RowNames)
data_matrix$RowNames <- sub("_[0-9]+$", "", data_matrix$RowNames)

# Print first few rows to inspect the data
head(data_matrix)

# Check the RowNames column
print(data_matrix$RowNames)

# Apply the sub function and inspect the result
genotype_names <- sub("_[0-9]+$", "", data_matrix$RowNames)
print(genotype_names)

# Check the length of the resulting vector
length(genotype_names)
length(data_matrix$RowNames)

# Assign the result to the new column only if the lengths match
if (length(genotype_names) == length(data_matrix$RowNames)) {
  data_matrix$Genotype <- genotype_names
} else {
  stop("Mismatch in lengths: Cannot assign Genotype column")
}

# Check the resulting data frame
head(data_matrix)

# Extracting genotype names
genotypes <- unique(data_matrix$RowNames)
genotypes

#get averages for eigengenes
averages <- data_matrix %>%
  group_by(Genotype) %>%
  summarise(across(starts_with("ME"), \(x) mean(x, na.rm = TRUE)))

# View the result
print(averages)

# write excel file (delete the G0 column and add fitness averages)
writexl::write_xlsx(averages, "eigengen_avg_signed_16thpwr_unmerged_07162024.xlsx")


# input file path to data matrix
file_path <- "eigengen_avg_signed_16thpwr_unmerged_07162024.xlsx"
data_matrix <- read_excel(file_path)
head(df)

# Extracting genotype names
genotypes <- unique(data_matrix$genotype)
genotypes

# Load necessary libraries
library(dplyr)
library(ggplot2)

# Run the linear models and extract coefficients and R^2 values
results <- lapply(names(data_matrix)[3:90], function(gene_name) {
  lm_fit <- lm(fitness ~ get(gene_name), data = data_matrix)
  summary_fit <- summary(lm_fit)
  coefficients <- summary_fit$coefficients
  r_squared <- summary_fit$r.squared  # Extract R^2 value
  
  # Create a data frame for the current model's coefficients
  df <- data.frame(
    gene = gene_name,
    term = rownames(coefficients),
    estimate = coefficients[, "Estimate"],
    std_error = coefficients[, "Std. Error"],
    t_value = coefficients[, "t value"],
    p_value = coefficients[, "Pr(>|t|)"],
    r_squared = r_squared  # Add R^2 value
  )
  
  return(df)
})

writexl::write_xlsx(results_df, "lmfit_results_signed_16thpwr_unmerged_07162024.xlsx")

# make scatter plot
# Assuming 'data_matrix' is your data frame and you want to plot for 'gene1'
gene_name <- "MEantiquewhite4"

# Create the scatter plot with the regression line
ggplot(data = data_matrix, aes_string(x = gene_name, y = "fitness")) +
  geom_point() +  # Scatter plot
  geom_smooth(method = "lm", col = "blue") +  # Regression line
  labs(title = paste("Scatter plot of", gene_name, "vs Fitness"),
       x = gene_name,
       y = "Fitness") +
  theme_minimal()

# Create an empty list to store the plots
plots <- list()

# Filter results for the "ME" module
me_thistle_results <- results[sapply(results, function(x) x$gene_name == "MEthistle")]

# Loop through each regression result for the "ME" module
for (result in MEdarkolivegreen4_results) {
  # Extract relevant information
  eigengene_name <- result$eigengene
  lm_fit <- result$model
  
  # Calculate R-squared value and p-value
  rsquared <- summary(lm_fit)$r.squared
  pvalue <- summary(lm_fit)$coefficients[2, 4]  # Extract p-value for the eigengene variable
  pvalue_rounded <- round(pvalue, 3)  # Round p-value to 3 digits
  
  # Create a scatter plot with the fitted regression line
  plot <- ggplot(data = data_matrix, aes_string(x = eigengene_name, y = "fitness")) +
    geom_point(aes(label = genotype), size = 3) +  # Add genotype labels without jitter
    geom_smooth(method = "lm", se = TRUE, color = "blue") + # Add regression line
    labs(x = "average eigengene", y = "average # eggs per gall") +  # Adjust axis labels
    ggtitle(paste(eigengene_name)) +
    theme_minimal() +
    annotate("text", x = Inf, y = -Inf, 
             label = paste("R^2 =", round(rsquared, 3), "\n", "P-value =", pvalue_rounded),
             hjust = 1, vjust = -0.2, size = 7) +  # Add R^2 and p-value to the plot
    theme(axis.title.x = element_text(size = 20),  # Increase font size for x-axis title
          axis.title.y = element_text(size = 20),  # Increase font size for y-axis title
          plot.title = element_text(size = 20))   # Increase font size for plot title
  
  # Store the plot in the list
  plots[[eigengene_name]] <- plot
}

# Print the plots
for (eigengene_name in names(plots)) {
  print(plots[[eigengene_name]])
}



## merging gene module assignment to genome annotation summary excel file 
# load genome annotation file
annot_file <- read.csv("transdata2.csv")
annot_file <- annot_file[-c(16:55)] # remove count data (only need annotation info)

#load the gene module assignment file
module_df <- read_xlsx("gene_mod_assign_signed_16thpwr_unmerged_07162024.xlsx")
colnames(module_df)[1] ="fasta3.1ID"

#write a new file with gene modules and annotation info
df <- merge(module_df, annot_file, by = 'fasta3.1ID', all = FALSE)
writexl::write_xlsx(df, "gene_mod_assign_signed_16thpwr_unmerged_07162024.xlsx")

# create new dataframe to subset modules
MEthistle_df <- df[df$ModuleAssignment == "thistle", ]
dim(MEthistle_df)
# [1] 39 16

MEdarkolivegreen4_df <- df[df$ModuleAssignment == "darkolivegreen4", ]
dim(MEdarkolivegreen4_df)
# [1] 54 16

MEgrey_df <- df[df$ModuleAssignment == "grey", ]
dim(MEgrey_df)
# [1] 574  16

MEdarkorange2_df <- df[df$ModuleAssignment == "darkorange2", ]
dim(MEdarkorange2_df)
#[1] 90 16
MEantiquewhite4_df <- df[df$ModuleAssignment == "antiquewhite4", ]
dim(MEantiquewhite4_df)
#[1] 66 16


# get sample sizes
samplesize <- annot_file %>% 
  group_by(AnnotGroup)%>% 
  tally()
samplesize

## perform fischers exact test for gene enrichment in the co-expression modules 

library(readxl)
setwd("/Users/natecollison/Desktop/DV_RNAseq_10.2023")
getwd()
# Assuming df_genes is your dataframe containing gene information with 'color' and 'AnnotGroup' columns
# And df_all_genes is your dataframe containing all genes with the 'AnnotGroup' column

#df_genes <- read_xlsx("gene_mod_assign_signed_16thpwr_unmerged_07162024.xlsx")
df_genes <- df
df_all_genes <- read.csv("transdata2.csv")
df_all_genes <- df_all_genes[-c(16:55)] # remove gene expression data, only retain gene annotation information
# Subset genes in the green and salmon modules

modules_of_interest <- c('thistle') # 
modules_of_interest <- c('darkolivegreen4') # 
modules_of_interest <- c('grey') # 
modules_of_interest <- c('darkorange2') # 
modules_of_interest <- c('antiquewhite4') # 

df_genes_subset <- subset(df_genes, ModuleAssignment %in% modules_of_interest)

# Get unique annotation groups
unique_groups <- unique(df_all_genes$AnnotGroup)

# Initialize vectors to store p-values and odds ratios
p_values <- numeric(length(unique_groups))
odds_ratios <- numeric(length(unique_groups))

# Perform Fisher's exact test for each group and store the p-values and odds ratios
for (i in seq_along(unique_groups)) {
  group <- unique_groups[i]
  
  # Count genes in the module belonging to the current annotation group
  group_count_module <- sum(df_genes_subset$AnnotGroup == group)
  
  # Count genes in the entire dataset belonging to the current annotation group
  group_count_all <- sum(df_all_genes$AnnotGroup == group)
  
  # Create a contingency table
  contingency_table <- matrix(c(group_count_module, sum(df_genes_subset$AnnotGroup != group),
                                group_count_all - group_count_module, sum(df_all_genes$AnnotGroup != group)),
                              nrow = 2, byrow = TRUE)
  
  # Perform Fisher's exact test
  fisher_test_result <- fisher.test(contingency_table)
  
  # Store the p-value and odds ratio
  p_values[i] <- fisher_test_result$p.value
  odds_ratios[i] <- fisher_test_result$estimate
}


# Create a data frame to store annotation groups, adjusted p-values, and odds ratios
results <- data.frame(
  AnnotationGroup = unique_groups,
  PValue = p_values,
  OddsRatio = odds_ratios,
  stringsAsFactors = FALSE
)



###
